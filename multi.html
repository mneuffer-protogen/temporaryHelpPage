<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High-Fidelity Battery Rack Sim</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1a1a1a;
            color: #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; 
        }

        h2 { margin-top: 10px; font-weight: 300; letter-spacing: 1px; }
        .controls { margin-bottom: 20px; font-size: 0.9em; color: #777; }

        /* --- RACK CONTAINER --- */
        .rack-container {
            position: relative;
            display: flex;
            gap: 40px; /* Space for inter-block cables */
            padding: 50px;
            background: #252525;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            margin-bottom: 40px;
        }

        /* --- BATTERY BLOCK (3 Cells) --- */
        .battery {
            width: 220px;  /* Larger */
            height: 280px; /* Larger */
            background: linear-gradient(to bottom, #0066cc 60px, #e0e0e0 60px);
            border-radius: 6px;
            border: 2px solid #111;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.4), 5px 5px 15px rgba(0,0,0,0.3);
            position: relative;
            display: flex;
            justify-content: space-around;
            padding-top: 15px;
        }

        .battery::after {
            content: attr(data-label);
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
            color: #444;
            opacity: 0.8;
        }

        /* --- CELLS & TERMINALS --- */
        .cell-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 30%;
            position: relative;
            z-index: 10;
        }

        .vent {
            width: 28px; height: 28px;
            background: #fbc02d;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            border: 2px solid #bba000;
            margin-bottom: 8px;
        }

        .terminal {
            width: 32px; height: 32px;
            background: #333;
            border: 3px solid #666;
            border-radius: 50%; /* Circular post base */
            position: relative;
            cursor: crosshair;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            margin-bottom: 12px;
        }

        /* Inner metal post look */
        .terminal::after {
            content: '';
            position: absolute;
            top: 6px; left: 6px;
            width: 14px; height: 14px;
            background: #999;
            border-radius: 50%;
            border: 1px solid #bbb;
        }

        .terminal:hover { border-color: white; transform: scale(1.1); transition: 0.1s; }
        .terminal.pos { border-color: #d32f2f; }
        .terminal.neg { border-color: #444; }

        /* --- MULTIMETER UI --- */
        .multimeter {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 240px;
            height: 380px;
            background: #ffcc00;
            border-radius: 16px;
            border: 6px solid #222;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 30px;
            z-index: 5;
        }

        .screen {
            width: 80%;
            height: 70px;
            background: #9ea792;
            border: 3px solid #444;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 15px;
            color: #111;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        /* --- PROBES --- */
        .probe {
            position: absolute;
            width: 20px; 
            height: 140px; /* Long handle */
            cursor: grab;
            z-index: 1000;
            filter: drop-shadow(5px 10px 10px rgba(0,0,0,0.5));
            transform-origin: center bottom;
        }
        .probe:active { cursor: grabbing; transform: scale(0.98); }

        .probe-handle {
            width: 20px; height: 90px;
            border-radius: 4px;
            position: absolute;
            top: 0; left: 0;
        }
        .probe-red .probe-handle { background: #cc0000; }
        .probe-black .probe-handle { background: #111; }

        .probe-tip {
            width: 4px; height: 50px;
            background: linear-gradient(to right, #ccc, #fff, #999);
            position: absolute;
            bottom: -50px; /* Sticks out bottom */
            left: 8px;
            border-radius: 0 0 2px 2px;
        }
        
        /* The collision point visualizer (debug only, currently hidden) */
        .hotspot {
            width: 4px; height: 4px;
            background: lime;
            position: absolute;
            bottom: -50px; left: 8px;
            border-radius: 50%;
            display: none; 
        }

        /* --- SVG LAYER (Wires & Straps) --- */
        #connections-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20; /* Above terminals for realism */
        }
        
        /* Style for battery straps */
        .strap { stroke: #999; stroke-width: 14; stroke-linecap: round; fill: none; }
        .cable { stroke: #111; stroke-width: 10; stroke-linecap: round; fill: none; }
        .cable-highlight { stroke: #333; stroke-width: 4; stroke-linecap: round; fill: none; opacity: 0.5; }

        /* Multimeter Wires */
        #meter-wires {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>

    <h2>Series Battery Rack Simulation</h2>
    <div class="controls">Drag probes by the handle. The active sensing point is the very tip of the metal needle.</div>

    <div class="rack-container" id="rack">
        <svg id="connections-layer"></svg>
    </div>

    <div class="multimeter" id="meter">
        <div class="screen" id="display">0.00 V</div>
        <div style="color: #444; font-size: 0.8em; margin-top: auto; margin-bottom: 20px;">FLUKE SIM</div>
    </div>

    <svg id="meter-wires">
        <path id="wire-red" stroke="#cc0000" stroke-width="4" fill="none" />
        <path id="wire-black" stroke="#222" stroke-width="4" fill="none" />
    </svg>

    <div id="probe-red" class="probe probe-red" style="top: 500px; left: 600px;">
        <div class="probe-handle"></div>
        <div class="probe-tip"></div>
        <div class="hotspot"></div>
    </div>

    <div id="probe-black" class="probe probe-black" style="top: 500px; left: 500px;">
        <div class="probe-handle"></div>
        <div class="probe-tip"></div>
        <div class="hotspot"></div>
    </div>

    <script>
        const config = {
            numBatteries: 4,
            cellsPerBat: 3,
            voltagePerCell: 2.05,
            batteryWidth: 220,
            gap: 40
        };

        const rack = document.getElementById('rack');
        const svgLayer = document.getElementById('connections-layer');
        const terminals = []; // Array to store terminal data and DOM elements

        // --- 1. BUILD THE RACK ---
        function initRack() {
            // We build left to right.
            // Bat 1 (Left) = High Voltage
            // Bat 4 (Right) = Ground (0V)
            
            // Total Cells = 12. 
            // Cell Index 0 = Ground (Bat 4, Cell 3)
            // Cell Index 11 = Max Volts (Bat 1, Cell 1)
            
            // Let's iterate visual order: Bat 1 -> Bat 4
            for (let b = 0; b < config.numBatteries; b++) {
                const batDiv = document.createElement('div');
                batDiv.className = 'battery';
                batDiv.setAttribute('data-label', `Bat ${b + 1}`);
                
                // We need to track terminals to draw straps later
                const batTerminals = []; 

                // 3 Cells per battery
                for (let c = 0; c < config.cellsPerBat; c++) {
                    // Logic to map Visual Index to Electrical Potential
                    // Visual: Bat 1 (b=0) is top of string.
                    // Cell 1 (c=0) is the absolute positive end.
                    
                    // Total Cells = 12
                    // Global Cell ID (0 is highest potential cell, 11 is ground cell)
                    // globalID = (b * 3) + c
                    
                    // But potential is reverse. 
                    // Ground is at end of chain.
                    const totalCells = config.numBatteries * config.cellsPerBat;
                    const cellIndexInv = totalCells - 1 - ((b * 3) + c); 
                    
                    // Potential logic
                    // Pos Terminal = (Index + 1) * 2.05
                    // Neg Terminal = Index * 2.05
                    const posVolts = (cellIndexInv + 1) * config.voltagePerCell;
                    const negVolts = cellIndexInv * config.voltagePerCell;

                    const col = document.createElement('div');
                    col.className = 'cell-column';
                    
                    // Vent
                    const vent = document.createElement('div');
                    vent.className = 'vent';
                    
                    // Positive Term
                    const tPos = document.createElement('div');
                    tPos.className = 'terminal pos';
                    tPos.dataset.volts = posVolts.toFixed(2);
                    
                    // Negative Term
                    const tNeg = document.createElement('div');
                    tNeg.className = 'terminal neg';
                    tNeg.dataset.volts = negVolts.toFixed(2);

                    col.append(vent, tPos, tNeg);
                    batDiv.append(col);
                    
                    // Store for drawing lines
                    // We push them in visual order: Pos, Neg
                    batTerminals.push(tPos, tNeg);
                    terminals.push({el: tPos, val: posVolts}, {el: tNeg, val: negVolts});
                }
                
                rack.appendChild(batDiv);

                // --- DRAW INTERNAL STRAPS ---
                // Wait for DOM layout
                requestAnimationFrame(() => {
                    // Strap 1: Connect Cell 1 Neg (Index 1) to Cell 2 Pos (Index 2)
                    drawStrap(batTerminals[1], batTerminals[2]);
                    // Strap 2: Connect Cell 2 Neg (Index 3) to Cell 3 Pos (Index 4)
                    drawStrap(batTerminals[3], batTerminals[4]);
                });
            }

            // --- DRAW EXTERNAL CABLES ---
            // Connect Bat 1 Last Neg to Bat 2 First Pos
            // We need global indices.
            // Bat 1 Last Neg is terminal index 5
            // Bat 2 First Pos is terminal index 6
            setTimeout(() => {
                const allTerms = document.querySelectorAll('.terminal');
                // Connections at: 5->6, 11->12, 17->18
                drawCable(allTerms[5], allTerms[6]);
                drawCable(allTerms[11], allTerms[12]);
                drawCable(allTerms[17], allTerms[18]);
            }, 100);
        }

        function drawStrap(el1, el2) {
            const r1 = el1.getBoundingClientRect();
            const r2 = el2.getBoundingClientRect();
            const rackRect = rack.getBoundingClientRect();

            // Calculate center points relative to SVG container
            const x1 = r1.left + r1.width/2 - rackRect.left;
            const y1 = r1.top + r1.height/2 - rackRect.top;
            const x2 = r2.left + r2.width/2 - rackRect.left;
            const y2 = r2.top + r2.height/2 - rackRect.top;

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", `M ${x1} ${y1} L ${x2} ${y2}`);
            path.setAttribute("class", "strap");
            svgLayer.appendChild(path);
        }

        function drawCable(el1, el2) {
            const r1 = el1.getBoundingClientRect();
            const r2 = el2.getBoundingClientRect();
            const rackRect = rack.getBoundingClientRect();

            const x1 = r1.left + r1.width/2 - rackRect.left;
            const y1 = r1.top + r1.height/2 - rackRect.top;
            const x2 = r2.left + r2.width/2 - rackRect.left;
            const y2 = r2.top + r2.height/2 - rackRect.top;

            // Make a loop
            const loopDrop = 40; 
            const d = `M ${x1} ${y1} C ${x1} ${y1-loopDrop}, ${x2} ${y2-loopDrop}, ${x2} ${y2}`;

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", d);
            path.setAttribute("class", "cable");
            svgLayer.appendChild(path);
        }

        initRack();


        // --- 2. MULTIMETER LOGIC ---
        
        const probes = {
            red: { el: document.getElementById('probe-red'), val: null, x:0, y:0 },
            black: { el: document.getElementById('probe-black'), val: null, x:0, y:0 }
        };
        
        const display = document.getElementById('display');
        const wireRed = document.getElementById('wire-red');
        const wireBlack = document.getElementById('wire-black');
        const meterRect = document.getElementById('meter').getBoundingClientRect();

        let activeProbe = null;
        let offset = {x:0, y:0};

        [probes.red, probes.black].forEach(p => {
            p.el.addEventListener('mousedown', (e) => startDrag(e, p));
        });

        function startDrag(e, pObj) {
            e.preventDefault();
            activeProbe = pObj;
            const rect = pObj.el.getBoundingClientRect();
            offset.x = e.clientX - rect.left;
            offset.y = e.clientY - rect.top;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
        }

        function drag(e) {
            if(!activeProbe) return;
            
            // Move Element
            const x = e.clientX - offset.x;
            const y = e.clientY - offset.y;
            activeProbe.el.style.left = x + 'px';
            activeProbe.el.style.top = y + 'px';

            // Calculate Tip Position (Hotspot)
            // The handle is 90px tall. The tip is 50px long below that.
            // Total height roughly 140px. 
            // The tip x is roughly +10px from left.
            
            // We need absolute coordinates of the tip for collision
            const currentRect = activeProbe.el.getBoundingClientRect();
            
            // Fine-tuned offsets based on CSS
            const tipX = currentRect.left + 10; 
            const tipY = currentRect.top + 140; // Bottom of the metal tip

            checkCollision(activeProbe, tipX, tipY);
            updateWires();
        }

        function endDrag() {
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            activeProbe = null;
        }

        function checkCollision(pObj, x, y) {
            let hit = false;
            
            // Check all terminal divs
            // We use the 'terminals' array we built earlier to save DOM queries
            const allDOMTerms = document.querySelectorAll('.terminal');
            
            allDOMTerms.forEach(term => {
                const r = term.getBoundingClientRect();
                
                // Collision Box: Relaxed slightly to make it easier to hit
                if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) {
                    hit = true;
                    pObj.val = parseFloat(term.dataset.volts);
                    
                    // Visual feedback
                    term.style.borderColor = "#fff";
                    term.style.boxShadow = "0 0 15px white";
                } else {
                    // Reset
                    term.style.boxShadow = "none";
                    if(term.classList.contains('pos')) term.style.borderColor = "#d32f2f";
                    else term.style.borderColor = "#444";
                }
            });

            if(!hit) pObj.val = null;
            updateDisplay();
        }

        function updateDisplay() {
            if(probes.red.val !== null && probes.black.val !== null) {
                let v = probes.red.val - probes.black.val;
                display.innerText = v.toFixed(2) + " V";
            } else {
                display.innerText = "0.00 V";
            }
        }

        function updateWires() {
            // Anchor at meter bottom
            // Red anchor roughly left+180, Black roughly left+60
            const mR = document.getElementById('meter').getBoundingClientRect();
            
            drawWire(probes.red.el, mR.left + 160, mR.bottom - 40, wireRed);
            drawWire(probes.black.el, mR.left + 80, mR.bottom - 40, wireBlack);
        }

        function drawWire(probeEl, startX, startY, pathEl) {
            const r = probeEl.getBoundingClientRect();
            // Connect to top of handle
            const endX = r.left + 10;
            const endY = r.top;
            
            const d = `M ${startX} ${startY} Q ${startX} ${endY - 50} ${endX} ${endY}`;
            pathEl.setAttribute('d', d);
        }

        // Initial wire draw
        setTimeout(updateWires, 100);

    </script>
</body>
</html>
